%% Exponential distribution
%
%  Python: https://github.com/PennNGG/Quantitative-Neuroscience/blob/master/Probability%20Distributions/Python/Exponential.ipynb
%
% This distribution describes the frequency of occurrence of CONTINUOUS
%  events that decays exponentially with larger values.

% Start by comparing the simulated exponential from above to the formal pdf
% mu (mean) of the exponential pdf is the inverse of the Poisson rate
cla reset; hold on;

% Get the histogram
[N,X] = hist(intervalsBetweenEvents, 50);

% Here the interval is a continuous variable (note that the x-axis is 
%   binned in the histogram to visualize it, but the actual values can 
%   take on any continuous value because they represent the amount of 
%   time since the previous event), so to normalize the histogram to make a pdf we
%   can't just sum the values -- we have to sum the values multiplied by the
%   bin width (i.e., take the integral). We use matlab's "trapz" which
%   treats each bin as a trapezoid (because the heights before and after can
%   be slightly different) to compute the integral:
normalizedIntervals = N./trapz(X, N);
bar(X,normalizedIntervals);

% Plot the exponential pdf, with mean (mu) equal to 1/lambda
plot(X, exppdf(X, 1/lambda), 'ro-', 'MarkerSize', 10, 'LineWidth', 2);

% Labels, etc
title('Exponential probability distribution = distribution of intervals between events in a Poisson process')
xlabel('Interval duration (sec)');
ylabel('Probability')
legend('Simulated', 'Theoretical')

%%%
%
% Here's a better way to simulate a Poisson process: instead of
% approximating continuous time with small time bins, directly simulate the
% (continuous) time between events as an exponential
lambda = 2; % events/sec
M = 5000; % events/run
N = 1000; % number of runs

% The mean of the (exponential) distribution of intervals between events
%  generated by a Poisson process is equal to the inverse of the rate at 
%  which the events are generated (because time/event is the inverse of
%  events/time)
mu = 1/lambda; 

% Simulate a bunch of intervals picked from an exponential distribution
intervals = exprnd(mu, M, N);

% Sum them per run (columns) so the events correspond to timestamps
times = cumsum(intervals);

% A bit of a cheat -- find the run with the shortest time, then use that as
% the interval to test across runs
minTime = min(times(end,:));
fprintf('min_time = %.2f\n', minTime)

% Count the times less than the min interval per run
counts = sum(times<=minTime)';

% Check mean, var (for a simulated Posson process, the mean and var should
% be pretty close to each other -- where "pretty close" is going to depend
% on factors like N and M)
fprintf('lambda*deltaT = %.2f, mean = %.2f, var = %.2f\n', ...
   lambda*minTime, mean(counts), var(counts))

% Now let's consider the "Randomness" of this process in more detail.
% We say that it has a "flat hazard function": at any given point in time, 
%  there is an equal probabilty of the event occuring, given that it 
%  hasn't occurred yet. We can compute this function from the simulated 
%  intervals as the pdf/(1-cdf) [that is, the probability of a given 
%  interval, defined as the pdf, divided by 1 - the probablity that the
%  given interval occurred]:

% Compute over this range. See below for an explanation of what the upper
% range (here scaled by rangeScale) does to the calcluation.
rangeScale = 10;
xs = 0:0.01:mu*rangeScale;

% Compute separately per run, will store in this matrix
hazards = zeros(length(xs), N);

% Loop through the runs
for ii = 1:N
   
   % Get the histogram of intervals using bins defined by "xs"
   counts = hist(intervals(intervals(:,ii)<minTime, ii), xs);
   
   % Convert into a pdf, using trapz because the intervals are continuous
   pdf = counts./trapz(xs, counts);

   % Compute the cdf -- again using trapz 
   cdf = cumtrapz(xs, pdf);
   
   % Save the hazard
   hazards(:,ii) = pdf./(1-cdf);
end

% Show the mean hazard across runs. Notice that: 
%  1. it is roughly constant and equal to 2 --- which is the rate (lambda) 
%     that we started with above (and the inverse of the mean of the 
%     exponential distribution of intervals that we generated).
%  2. The mean is noisy, especially for long intervals (large values
%     along the x-axis) - this is because those intervals don't happen very
%     much (the long tail of the exponential distribution) so even with
%     large N those points are undesampled.
%  3. For very large intervals, the results are not just noisy, but biased
%     (the hazard rate starts to sweep upwards on the right of the figure).
%     This is because the true exponential has a tail that goes to
%     infinity, but here we stop it at some finite time. This procedure
%     implies that events that in a real Poisson process (with a real flat
%     hazard) would occur after a very long interval will be counted here as
%     bunching up in the longest bins we check -- so the probability of
%     occurrance in those bins will be slighly higher than expected for a
%     real exponential, making the hazard rate larger, too. You can make
%     this effect more pronounced by choosing a shorter range of xs, above.
cla reset;
plot(xs, mean(hazards,2))
xlabel('Time from prior event (sec)')
ylabel('Hazard rate of event occurring')